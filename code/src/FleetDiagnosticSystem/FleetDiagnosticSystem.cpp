#include <iostream>
#include <string>
#include <vector>
#include <unordered_map>
#include <unordered_set>

using namespace std;

/*
 * Problem Statement:
 * You are tasked with building a Fleet Diagnostic System for a fleet of Machine Learning (ML) Accelerator SoCs 
 * deployed across multiple data centers. These SoCs are responsible for running critical ML workloads, and the 
 * system must monitor and maintain the fleetâ€™s health and uptime by analyzing error reports generated during 
 * diagnostic runs.
 *
 * Known Details:
 * - Error Report:
 *  - Each error report includes:
 *   - chipID: A unique string identifier for each SoC, such as "SoC_1", "SoC_2", etc.
 *   - errorType: A string describing the type of error, which can be "CRITICAL", "WARNING", or "INFO".
 *  - The diagnostic system generates these error reports continuously and needs to process them in batches.
 * - Objectives:
 *  - Collect and analyze error reports efficiently.
 *  - Identify SoCs with the highest frequency of errors to prioritize maintenance and troubleshooting.
 *  - Track and highlight SoCs that have experienced at least one "CRITICAL" error, as these require immediate 
 *    attention.
 *
 * Requirements:
 * - Design and implement the Fleet Diagnostic System using OOP principles:
 *  - Create an ErrorReport class to represent individual error reports.
 *  - Design a DiagnosticAnalyzer class to handle the analysis of error reports, including:
 *   - Counting the total number of errors for each SoC.
 *   - Sorting SoCs by the frequency of errors in descending order.
 *   - Identifying SoCs that have had at least one "CRITICAL" error.
 *
 * Constraints:
 * - The solution should be efficient in terms of time and space complexity.
 * - Use only unordered_map and unordered_set for data storage and avoid using built-in algorithms like <algorithm>.
 * - Implement a custom sorting algorithm.
 *
 * Example Scenario
 * - Imagine the following batch of error reports:
 *   vector<ErrorReport> errorReports = {
 *     ErrorReport("SoC_1", "WARNING"),
 *     ErrorReport("SoC_2", "CRITICAL"),
 *     ErrorReport("SoC_3", "INFO"),
 *     ErrorReport("SoC_1", "CRITICAL"),
 *     ErrorReport("SoC_2", "WARNING"),
 *     ErrorReport("SoC_3", "CRITICAL"),
 *     ErrorReport("SoC_1", "INFO"),
 *     ErrorReport("SoC_3", "WARNING"),
 *     ErrorReport("SoC_2", "CRITICAL")
 *  };
 *
 * The system should:
 *  - Count the total errors for each chipID: SoC_1 (3 errors), SoC_2 (3 errors), SoC_3 (3 errors).
 *  - Sort the chipIDs by total error count in descending order: ["SoC_1", "SoC_2", "SoC_3"] 
 *    (or any permutation, as all have equal counts).
 *  - Identify chipIDs with at least one "CRITICAL" error: ["SoC_1", "SoC_2", "SoC_3"].
 * 
 * Objectives in Detail:
 * - Collect Error Reports:
 *  - The system must efficiently collect error reports, maintaining a count of errors for each chipID and tracking 
 *    which SoCs have encountered "CRITICAL" errors.
 * - Analyze and Prioritize:
 *  - Identify SoCs with the highest number of errors to aid in prioritizing maintenance.
 *  - Highlight SoCs with "CRITICAL" errors to escalate for immediate troubleshooting.
 * - Custom Sorting Logic:
 *  - Implement a custom sorting mechanism to order the SoCs by error frequency, as built-in sorting functions are not 
 *    allowed.
 * 
 * Classes and Their Responsibilities
 *  - ErrorReport Class:
 *   - Attributes: chipID (string), errorType (string)
 *   - Purpose: Represents individual error reports generated by the SoCs.
 *  - DiagnosticAnalyzer Class:
 *   - Attributes:
 *    - errorCount: An unordered_map that maps each chipID to its total error count.
 *    - criticalErrorChipIDs: An unordered_set to track chipIDs that have experienced "CRITICAL" errors.
 *   - Methods:
 *    - addErrorReport(): Collects error reports and updates the internal data structures.
 *    - getChipIDsSortedByErrorCount(): Returns a list of chipIDs sorted by error count in descending order using a 
 *      custom sorting algorithm.
 *    - getCriticalErrorChipIDs(): Returns a list of chipIDs that have experienced "CRITICAL" errors.
 */

/* Class representing a single error report */
class ErrorReport
{
    public:
        string chipID;
        string errorType;

        /* Constructor */
        ErrorReport(const string &chipID, const string &errorType) : chipID(chipID), errorType(errorType) {}
};

/* Class to analyze and process error reports */
class DiagnosticAnalyzer
{
    private:
        /* To count errors per chipID */
        unordered_map<string, int> errorCount;
        /* To track chipIDs with "CRITICAL" errors */
        unordered_set<string>      criticalErrorChipIDs;

        /* Helper function to merge two sorted halves of the vecot */
        void performMergeSort(vector<string> &list, int left, int right);
        /* Helper function to merge sort recursively */
        void Merge(vector<string> &list, int left, int mid, int right);

    
    public:
        /* Method to add an error report to the system */
        void addErrorReport(const ErrorReport &report);
        /* Method to get chipIDs sorted by error count in descending order */
        vector<string> getChipIDsSortedByErrorCount(void);
        /* Method to get chipIDs that have had at least one "CRITICAL" error */
        vector<string> getCriticalErrorChipIDs(void);
};

void DiagnosticAnalyzer::addErrorReport(const ErrorReport &report)
{
    /* Increment error couunt for chipIDs */
    errorCount[report.chipID]++;

    /* Track chipIDs with "CRITICAL" errors */
    if (report.errorType == "CRITICAL")
    {
        criticalErrorChipIDs.insert(report.chipID);
    }
}

void DiagnosticAnalyzer::Merge(vector<string> &list, int left, int mid, int right)
{
    /* Caculate the size of the two sub-lists */
    int leftSize  = mid - left + 1;
    int rightSize = right - mid;

    /* Create temporary lists to hold the left and right halves */
    vector<string> leftList(leftSize);
    vector<string> rightList(rightSize);

    /* Copy data to the temporary lists */
    for (int i = 0; i < leftSize; i++)
    {
        leftList[i] = list[left + i];
    }

    for (int j = 0; j < rightSize; j++)
    {
        rightList[j] = list[mid + 1 + j];
    }

    /* Merge the two lists */
    int i = 0, j = 0, k = left;
    while ((i < leftSize) && (j < rightSize))
    {
        if (leftList[i] >= rightList[j])
        {
            list[k] = leftList[i];
            i++;
        }
        else
        {
            list[k] = rightList[j];
            j++;
        }
        k++;
    }

    /* Copy the remaining elements of leftList */
    while (i < leftSize)
    {
        list[k] = leftList[i];
        i++;
        k++;
    }

    /* Copy the remaining elements of rightList */
    while (j < rightSize)
    {
        list[k] = rightList[j];
        j++;
        k++;
    }
}

void DiagnosticAnalyzer::performMergeSort(vector<string> &list, int left, int right)
{
    if (left < right)
    {
        int mid = left + (right - left) / 2;

        #ifdef DEBUG
        // Print the current state before the recursive calls
        cout << "Recursively sorting left half: ";
        for (int i = left; i <= mid; ++i) {
            cout << list[i] << " ";
        }
        cout << endl;
        #endif

        /* Sort the left half */
        performMergeSort(list, left, mid);

        #ifdef DEBUG
        // Print the current state before the recursive call for the right half
        cout << "Recursively sorting right half: ";
        for (int i = mid + 1; i <= right; ++i) {
            cout << list[i] << " ";
        }
        cout << endl;
        #endif

        /* Sort the right half */
        performMergeSort(list, mid + 1, right);

        #ifdef DEBUG
        // Print the state before merging
        cout << "Merging: ";
        for (int i = left; i <= right; ++i) {
            cout << list[i] << " ";
        }
        cout << endl;
        #endif

        /* Merge the sorted halves */
        Merge(list, left, mid, right);

        #ifdef DEBUG
        // Print the state after merging
        cout << "After merging: ";
        for (int i = left; i <= right; ++i) {
            cout << list[i] << " ";
        }
        cout << endl;
        #endif
    }
}

vector<string> DiagnosticAnalyzer::getChipIDsSortedByErrorCount(void)
{
    /* Collect all chipIDs */
    vector<string> chipIDs;
    for (const auto &entry : errorCount)
    {
        chipIDs.push_back(entry.first);
        cout << "Adding chipID: " << entry.first << endl;
    }
    cout << endl;

    /* Sort the vector */
    performMergeSort(chipIDs, 0, chipIDs.size() - 1);
    
    /* Return the sorted vector */
    return chipIDs;
}

vector<string> DiagnosticAnalyzer::getCriticalErrorChipIDs(void)
{
    /* Convert the unordered set to a vector */
    return (vector<string>(criticalErrorChipIDs.begin(), criticalErrorChipIDs.end()));
}

void FleetDiagnosticSystemMain(void)
{
    /* Create an instance of DiagnosticAnalyzer */
    DiagnosticAnalyzer analyzer;

    /* Sample error reports */
    vector<ErrorReport> errorReports = {
        ErrorReport("SoC_1", "WARNING"),
        ErrorReport("SoC_2", "CRITICAL"),
        ErrorReport("SoC_3", "INFO"),
        ErrorReport("SoC_1", "CRITICAL"),
        ErrorReport("SoC_2", "WARNING"),
        ErrorReport("SoC_3", "CRITICAL"),
        ErrorReport("SoC_1", "INFO"),
        ErrorReport("SoC_3", "WARNING"),
        ErrorReport("SoC_2", "CRITICAL")
    };

    /* Add all error reports to the analyzer */
    for (const auto &report : errorReports) {
        analyzer.addErrorReport(report);
    }

    /* Get and print chipIDs sorted by error count */
    vector<string> chipIDsSorted = analyzer.getChipIDsSortedByErrorCount();
    cout << "Chip IDs sorted by total error count: ";
    for (const auto &chipID : chipIDsSorted) {
        cout << chipID << " ";
    }
    cout << endl;

    /* Get and print chipIDs with at least one "CRITICAL" error */
    vector<string> criticalChipIDs = analyzer.getCriticalErrorChipIDs();
    cout << "Chip IDs with at least one CRITICAL error: ";
    for (const auto &chipID : criticalChipIDs) {
        cout << chipID << " ";
    }
    cout << endl;
}